import{d as Ke,r as ne,b as We,o as Je,c as ze,a as c,u as T,w as re,v as se,i as oe}from"./app-CRWFFeb8.js";function et(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}const tt=self.crypto;function nt(r){const e=new Uint8Array(r);return tt.getRandomValues(e),e}var Oe={randomBytes:nt};const{randomBytes:rt}=Oe,B=16;let st=class{compare(e,t){const n=e.findIndex((s,o)=>s!==t[o]);return~n&&Math.sign(e[n]-t[n])}generateOneFilled(){return new Uint8Array(B).fill(255)}generateRandomFilled(){return rt(B)}generateZeroFilled(){return new Uint8Array(B).fill(0)}};var p=new st;class w extends Error{get name(){return this.constructor.name}}let ot=class extends w{},it=class extends w{},ct=class extends w{},at=class extends w{},dt=class extends w{};var x={Id128Error:w,ClockSequenceOverflow:ot,InvalidBytes:it,InvalidEncoding:ct,InvalidEpoch:at,UnsupportedVersion:dt};const{InvalidEpoch:ie}=x,ce=0,ae=Math.pow(2,48);let lt=class{fromEpoch(e,t){return new Date(t+e)}toEpoch(e,t=null){const s=(t===null?Date.now():Number.isInteger(t)?t:t instanceof Date?t.getTime():(()=>{throw new ie(`Failed to coerce time [${t}] to epoch`)})())-e;if(s<ce||s>=ae){const o=new Date(ce+e).toISOString(),d=new Date(ae-1+e).toISOString();throw new ie(`Epoch must be between ${o} and ${d}`)}return s}};var R=new lt;const ut=p,de=Symbol("bytes");let ht=class{constructor(e){this[de]=e}clone(){return new this.constructor(this.bytes.slice())}get bytes(){return this[de]}get[Symbol.toStringTag](){return this.constructor.name}compare(e){return ut.compare(this.bytes,e.bytes)}equal(e){return this.compare(e)===0}};var Se={BaseId:ht};const b=p,le=R,{BaseId:_t}=Se,Fe=0,ue=0,H=Math.pow(2,32),A=255;function Ne(r,e){const t=r%H,n=(r-t)/H;let s=Fe-1;e[++s]=n>>>8&A,e[++s]=n>>>0&A,e[++s]=t>>>24&A,e[++s]=t>>>16&A,e[++s]=t>>>8&A,e[++s]=t>>>0&A}let pt=class extends _t{static generate({time:e}={}){e=le.toEpoch(ue,e);let t=b.generateRandomFilled();return Ne(e,t),new this(t)}static MIN(){return new this(b.generateZeroFilled())}static MAX(){return new this(b.generateOneFilled())}get time(){let e=Fe-1;const t=0|this.bytes[++e]<<8|this.bytes[++e]<<0,n=0|this.bytes[++e]<<24|this.bytes[++e]<<16|this.bytes[++e]<<8|this.bytes[++e]<<0,s=t*H+(n>>>0);return le.fromEpoch(ue,s)}};var xe={Ulid:pt,setTime:Ne};const{Ulid:gt,setTime:mt}=xe,Et=p,ft=R,{ClockSequenceOverflow:It}=x,$t=0,Ve=6,Me=8,Tt=0;let L,D;function At(r){for(let e=Me-1,t=Ve-1;e>t;--e)if(r[e]===255)r[e]=0;else{++r[e];return}throw new It("Exhausted clock sequence")}function Ct(r){r[Ve]&=127}function wt(r){for(let e=$t;e<Me;++e)r[e]=L.bytes[e]}let Re=class extends gt{static reset(){D=-1,L=this.MIN()}static generate({time:e}={}){e=ft.toEpoch(Tt,e);let t=Et.generateRandomFilled();return e<=D?(wt(t),At(t)):(mt(e,t),Ct(t),D=e),L=new this(t)}};Re.reset();var vt={UlidMonotonic:Re};const{BaseId:Ut}=Se,he=p,j=8,Q=6;function Z(r,e){e[j]&=255>>>r+1,e[j]|=(7<<3-r&7)<<5}function P(r,e){e[Q]&=15,e[Q]|=r<<4}let yt=class extends Ut{static MIN(){let e=he.generateZeroFilled();return Z(this.VARIANT,e),P(this.VERSION,e),new this(e)}static MAX(){let e=he.generateOneFilled();return Z(this.VARIANT,e),P(this.VERSION,e),new this(e)}get variant(){const e=this.bytes[j]>>>5;return e===7?3:(e&6)===6?2:(e&4)===4?1:0}get version(){return this.bytes[Q]>>>4}};var V={Uuid:yt,setVersion:P,setVariant:Z};const{randomBytes:Ot}=Oe,k=Symbol("mac-address");class St{constructor(){this.reset()}get mac_address(){let e=this[k];return e||(e=this[k]=Ot(6),e[0]|=1),e}reset(){this[k]=null}}var Be=new St;const be=p,_e=R,Ft=Be,{Uuid:Nt,setVariant:xt,setVersion:Vt}=V,De=0,pe=2,O=8,ke=10,z=Math.pow(2,14),ge=Date.parse("1582-10-15Z"),Y=Math.pow(2,12),G=Math.pow(2,20),u=255;let I,C,S;function qe(){I=(I+1)%z}function Mt(r,e){if(I===null){const n=be.generateRandomFilled();I=(0|n[O+0]<<8|n[O+1]<<0)%z}else r<S&&qe();let t=O-1;e[++t]=I>>>8&u,e[++t]=I>>>0&u}function Rt(r,e){for(let t=0;t<6;++t)e[ke+t]=r[t]}function Bt(r,e){C=r>S?0:C+1,C===Y&&(C=0,qe());const t=r%G,n=t*Y+C,s=(r-t)/G;let o=De-1;e[++o]=n>>>24&u,e[++o]=n>>>16&u,e[++o]=n>>>8&u,e[++o]=n>>>0&u,e[++o]=s>>>8&u,e[++o]=s>>>0&u,e[++o]=s>>>24&u,e[++o]=s>>>16&u}let Xe=class extends Nt{static get VARIANT(){return 1}static get VERSION(){return 1}static reset(){I=null,C=-1,S=-1}static generate({node:e,time:t}={}){t=_e.toEpoch(ge,t);let n=be.generateZeroFilled();return Bt(t,n),Mt(t,n),Rt(e||Ft.mac_address,n),xt(this.VARIANT,n),Vt(this.VERSION,n),t>S&&(S=t),new this(n)}get clock_sequence(){return(0|this.bytes[O]<<8|this.bytes[O+1])&z-1}get hires_time(){return(0|this.bytes[pe]<<8|this.bytes[pe+1])&Y-1}get node(){return this.bytes.slice(ke)}get time(){let e=De-1;const t=0|this.bytes[++e]<<12|this.bytes[++e]<<4|this.bytes[++e]>>>4;++e;const s=(0|this.bytes[++e]<<8|this.bytes[++e]<<0|(this.bytes[++e]&15)<<24|this.bytes[++e]<<16)*G+t;return _e.fromEpoch(ge,s)}};Xe.reset();var bt={Uuid1:Xe};const Dt=p,{Uuid:kt,setVariant:qt,setVersion:Xt}=V;let Ht=class extends kt{static get VARIANT(){return 1}static get VERSION(){return 4}static generate(){let e=Dt.generateRandomFilled();return qt(this.VARIANT,e),Xt(this.VERSION,e),new this(e)}};var Lt={Uuid4:Ht};const He=p,me=R,jt=Be,{Uuid:Qt,setVariant:Zt,setVersion:Pt}=V,Le=0,Ee=6,F=8,je=10,ee=Math.pow(2,14),fe=Date.parse("1582-10-15Z"),Qe=Math.pow(2,12),K=Math.pow(2,32),h=255;let $,m,N;function Ze(){$=($+1)%ee}function Yt(r,e){if($===null){const n=He.generateRandomFilled();$=(0|n[F+0]<<8|n[F+1]<<0)%ee}else r<N&&Ze();let t=F-1;e[++t]=$>>>8&h,e[++t]=$>>>0&h}function Gt(r,e){for(let t=0;t<6;++t)e[je+t]=r[t]}function Kt(r,e){m=r>N?0:m+1,m===Qe&&(m=0,Ze());const t=r%K,n=(r-t)/K;let s=Le-1;e[++s]=n>>>8&h,e[++s]=n>>>0&h,e[++s]=t>>>24&h,e[++s]=t>>>16&h,e[++s]=t>>>8&h,e[++s]=t>>>0&h,e[++s]=m>>>8&h,e[++s]=m>>>0&h}let Pe=class extends Qt{static get VARIANT(){return 1}static get VERSION(){return 6}static reset(){$=null,m=-1,N=-1}static generate({node:e,time:t}={}){t=me.toEpoch(fe,t);let n=He.generateZeroFilled();return Kt(t,n),Yt(t,n),Gt(e||jt.mac_address,n),Zt(this.VARIANT,n),Pt(this.VERSION,n),t>N&&(N=t),new this(n)}get clock_sequence(){return(0|this.bytes[F]<<8|this.bytes[F+1])&ee-1}get hires_time(){return(0|this.bytes[Ee]<<8|this.bytes[Ee+1])&Qe-1}get node(){return this.bytes.slice(je)}get time(){let e=Le-1;const t=0|this.bytes[++e]<<8|this.bytes[++e]<<0,n=0|this.bytes[++e]<<24|this.bytes[++e]<<16|this.bytes[++e]<<8|this.bytes[++e]<<0,s=t*K+(n>>>0);return me.fromEpoch(fe,s)}};Pe.reset();var Wt={Uuid6:Pe};const Ie=p,{Uuid:Jt,setVariant:$e,setVersion:Te}=V;let zt=class extends Jt{static get VARIANT(){return 0}static get VERSION(){return 0}static generate(){let e=Ie.generateZeroFilled();return $e(this.VARIANT,e),Te(this.VERSION,e),new this(e)}static MAX(){let e=Ie.generateZeroFilled();return $e(this.VARIANT,e),Te(this.VERSION,e),new this(e)}};var en={UuidNil:zt};const{InvalidEncoding:tn,InvalidBytes:nn}=x,q=Symbol("valid_encoding_pattern");let rn=class{constructor({valid_encoding_pattern:e}={}){this[q]=e}decode(e){if(this.isValidEncoding(e))return this.decodeTrusted(e);throw new tn(`Encoding [${e}] does not satisfy ${this[q]}`)}decodeTrusted(e){return ByteArray.generateRandomFilled()}encode(e){if(this.isValidBytes(e))return this.encodeTrusted(e);throw new nn("Requires a 16-byte Uint8Array")}encodeTrusted(e){return""}isValidBytes(e){return e instanceof Uint8Array&&e.length===16}isValidEncoding(e){return(typeof e=="string"||e instanceof String)&&this[q].test(e)}};var te={BaseCoder:rn};const{BaseCoder:sn}=te,l="0123456789ABCDEFGHJKMNPQRSTVWXYZ",on=31,cn=Array.from(l).reduce((r,e,t)=>(r[e]=r[e.toLowerCase()]=t,r),{I:l.indexOf("1"),i:l.indexOf("1"),L:l.indexOf("1"),l:l.indexOf("1"),O:l.indexOf("0"),o:l.indexOf("0"),U:l.indexOf("V"),u:l.indexOf("V")}),an=Array.from(l);function dn(r){return cn[r]}function ln(r){return an[r&on]}let un=class extends sn{constructor(){super({valid_encoding_pattern:/^[0-7][^\W_]{25}$/})}decodeTrusted(e){const t=new Uint8Array(16),n=[];for(let s=0,o=e.length;s<o;++s)n.push(dn(e[s]));return t[0]=n[0]<<5|n[1],t[1]=n[2]<<3|n[3]>>2,t[2]=n[3]<<6|n[4]<<1|n[5]>>4,t[3]=n[5]<<4|n[6]>>1,t[4]=n[6]<<7|n[7]<<2|n[8]>>3,t[5]=n[8]<<5|n[9],t[6]=n[10]<<3|n[11]>>2,t[7]=n[11]<<6|n[12]<<1|n[13]>>4,t[8]=n[13]<<4|n[14]>>1,t[9]=n[14]<<7|n[15]<<2|n[16]>>3,t[10]=n[16]<<5|n[17],t[11]=n[18]<<3|n[19]>>2,t[12]=n[19]<<6|n[20]<<1|n[21]>>4,t[13]=n[21]<<4|n[22]>>1,t[14]=n[22]<<7|n[23]<<2|n[24]>>3,t[15]=n[24]<<5|n[25],t}encodeTrusted(e){let t=[e[0]>>5,e[0],e[1]>>3,e[1]<<2|e[2]>>6,e[2]>>1,e[2]<<4|e[3]>>4,e[3]<<1|e[4]>>7,e[4]>>2,e[4]<<3|e[5]>>5,e[5],e[6]>>3,e[6]<<2|e[7]>>6,e[7]>>1,e[7]<<4|e[8]>>4,e[8]<<1|e[9]>>7,e[9]>>2,e[9]<<3|e[10]>>5,e[10],e[11]>>3,e[11]<<2|e[12]>>6,e[12]>>1,e[12]<<4|e[13]>>4,e[13]<<1|e[14]>>7,e[14]>>2,e[14]<<3|e[15]>>5,e[15]],n="";for(let s=0,o=t.length;s<o;++s)n+=ln(t[s]);return n}};var hn=new un;const{BaseCoder:_n}=te,E="0123456789ABCDEF",pn=Array.from({length:E.length*E.length}).map((r,e)=>""+E.charAt(e/E.length)+E.charAt(e%E.length)),Ae=Array.from(E).reduce((r,e,t)=>Object.assign(r,{[e.toUpperCase()]:t,[e.toLowerCase()]:t}),Object.create(null));let gn=class extends _n{constructor(){super({valid_encoding_pattern:/^[0-9A-Fa-f]{32}$/})}decodeTrusted(e){let t=new Uint8Array(16);for(let n=0,s=!0,o=0,d=e.length;o<d;++o){const a=e[o];s?t[n]=Ae[a]<<4:t[n++]|=Ae[a],s=!s}return t}encodeTrusted(e){let t="";for(let n=0,s=e.length;n<s;++n)t+=pn[e[n]];return t}};var mn=new gn;const{BaseCoder:En}=te,f="0123456789ABCDEF",i=Array.from({length:f.length*f.length}).map((r,e)=>""+f.charAt(e/f.length)+f.charAt(e%f.length)),Ce=Array.from(f).reduce((r,e,t)=>Object.assign(r,{[e.toUpperCase()]:t,[e.toLowerCase()]:t}),Object.create(null));let fn=class extends En{constructor(){super({valid_encoding_pattern:/^[0-9A-Fa-f]{4}(?:-?[0-9A-Fa-f]{4}){7}$/})}decodeTrusted(e){let t=new Uint8Array(16);for(let n=0,s=!0,o=0,d=e.length;o<d;++o){const a=e[o];a!=="-"&&(s?t[n]=Ce[a]<<4:t[n++]|=Ce[a],s=!s)}return t}encodeTrusted(e){let t=-1;return""+i[e[++t]]+i[e[++t]]+i[e[++t]]+i[e[++t]]+"-"+i[e[++t]]+i[e[++t]]+"-"+i[e[++t]]+i[e[++t]]+"-"+i[e[++t]]+i[e[++t]]+"-"+i[e[++t]]+i[e[++t]]+i[e[++t]]+i[e[++t]]+i[e[++t]]+i[e[++t]]}};var In=new fn;const g=Symbol("id"),U=Symbol("canonical_coder"),y=Symbol("raw_coder");let $n=class{constructor({id:e,canonical_coder:t,raw_coder:n}={}){this[g]=class extends e{static get name(){return e.name}static get[Symbol.species](){return e}get[Symbol.toStringTag](){return`${e.name} ${this.toRaw()}`}toCanonical(){return t.encodeTrusted(this.bytes)}toRaw(){return n.encodeTrusted(this.bytes)}},this[U]=t,this[y]=n}get name(){return this[g].name}get type(){return this[g][Symbol.species]}construct(e){return new this[g](e)}generate(){return this[g].generate(...arguments)}MIN(){return this[g].MIN(...arguments)}MAX(){return this[g].MAX(...arguments)}fromCanonical(e){return this.construct(this[U].decode(e))}fromCanonicalTrusted(e){return this.construct(this[U].decodeTrusted(e))}fromRaw(e){return this.construct(this[y].decode(e))}fromRawTrusted(e){return this.construct(this[y].decodeTrusted(e))}toCanonical(e){return this[U].encode(e.bytes)}toRaw(e){return this[y].encode(e.bytes)}compare(e,t){return console.warn("Deprecated: use generic idCompare instead."),e.compare(t)}equal(e,t){return console.warn("Deprecated: use generic idEqual instead."),e.equal(t)}isCanonical(e){return this[U].isValidEncoding(e)}isRaw(e){return this[y].isValidEncoding(e)}};var Ye={IdFactory:$n};const{IdFactory:we}=Ye,{UnsupportedVersion:Ge}=x,W=Symbol("id_by_version");function M(r,{version:e}={}){return r[W][e]||(()=>{throw new Ge(`No support for version [${e}]`)})()}let Tn=class extends we{constructor({abstract_id:e,versioned_ids:t,canonical_coder:n,raw_coder:s}){super({id:e,canonical_coder:n,raw_coder:s}),this[W]=t.reduce((o,d)=>Object.assign(o,{[d.MIN().version]:new we({id:d,canonical_coder:n,raw_coder:s})}),Object.create(null))}get versioned_ids(){return Object.values(this[W])}construct(e){const t=super.construct(e),n=t.version;try{return M(this,{version:n}).construct(e)}catch(s){if(s instanceof Ge)return t;throw s}}generate(){return M(this,...arguments).generate(...arguments)}MIN(){return M(this,...arguments).MIN()}MAX(){return M(this,...arguments).MAX()}};var An={VersionedIdFactory:Tn};const{Ulid:Cn}=xe,{UlidMonotonic:wn}=vt,{Uuid:vn}=V,{Uuid1:Un}=bt,{Uuid4:yn}=Lt,{Uuid6:On}=Wt,{UuidNil:Sn}=en,ve=hn,X=mn,Fn=In,{IdFactory:Ue}=Ye,{VersionedIdFactory:Nn}=An,xn=x,J={idCompare:function(r,e){return r.compare(e)},idEqual:function(r,e){return r.equal(e)},Exception:xn,Ulid:new Ue({id:Cn,canonical_coder:ve,raw_coder:X}),UlidMonotonic:new Ue({id:wn,canonical_coder:ve,raw_coder:X}),Uuid:new Nn({abstract_id:vn,versioned_ids:[Un,yn,On,Sn],canonical_coder:Fn,raw_coder:X})};J.Uuid.versioned_ids.reduce((r,e)=>Object.assign(r,{[e.name]:e}),J);var Vn=J;const Mn=et(Vn),Rn=r=>{const e=document.createElement("textarea");e.value=r,e.style.top="0",e.style.left="0",e.style.position="fixed",document.body.appendChild(e),e.focus(),e.select();try{const n=document.execCommand("copy")?"successful":"unsuccessful";console.log("Fallback: Copying text command was "+n)}catch(t){console.error("Fallback: Oops, unable to copy",t)}document.body.removeChild(e)},ye=r=>{if(!navigator.clipboard){Rn(r);return}navigator.clipboard.writeText(r)},Bn=c("h1",null,"Ulid",-1),bn=c("label",{for:"ulid"},"ULID",-1),Dn=c("br",null,null,-1),kn=c("label",{for:"guid"},"GUID",-1),qn=c("br",null,null,-1),Xn=c("button",{type:"submit"},"NEW ID",-1),lr=Ke({__name:"ulid",setup(r){const{Ulid:e,Uuid4:t}=Mn,n=ne(""),s=ne(""),o=a=>{a.preventDefault(),d()},d=()=>{const a=e.generate();n.value=a.toCanonical(),s.value=t.fromRaw(a.toRaw()).toCanonical()};return We(()=>{d()}),(a,_)=>(Je(),ze("div",null,[Bn,c("form",{onSubmit:o},[c("div",null,[bn,c("button",{class:"copy-btn",type:"button",onClick:_[0]||(_[0]=v=>T(ye)(T(n)))}," copy "),Dn,re(c("input",{"onUpdate:modelValue":_[1]||(_[1]=v=>oe(n)?n.value=v:null),name:"ulid",type:"text",class:"id-input",readonly:""},null,512),[[se,T(n)]])]),c("div",null,[kn,c("button",{class:"copy-btn",type:"button",onClick:_[2]||(_[2]=v=>T(ye)(T(s)))}," copy "),qn,re(c("input",{"onUpdate:modelValue":_[3]||(_[3]=v=>oe(s)?s.value=v:null),name:"guid",type:"text",class:"id-input",readonly:""},null,512),[[se,T(s)]])]),Xn],32)]))}});export{lr as default};
